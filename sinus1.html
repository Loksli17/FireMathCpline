<canvas id="canvas" width="1200" height="500"></canvas>
<style>
	canvas{
		transform: rotate(180deg) rotateY(180deg);
	}
</style>





<script type="text/javascript">	


var canvas = document.getElementById('canvas');
var ctx = canvas.getContext("2d");

function Coord(x, y){
	this.x = x;
	this.y = y;
};

function Axle(len, step){
	this.len = len;
	this.step = step;
}


let h           = 0.01,
	cS          = 11, //масштаб
	off         = 50, //смещение в пикселях
	n           = 200,
	sinusTrue   = new Array(),
	stepSpline  = 20,
	sinusSpline = new Array();

//оси
let axisX = new Axle(1000, 20),
	axisY = new Axle(200, 100);
	

function inRad(num) {
	return num * Math.PI / 180;
}


function drawCinus(){
	ctx.strokeStyle = "blue";
	ctx.beginPath();

	for (i = 0; i <= n; i++) {
  		x = i * 3;
  		y = 110 * Math.sin(12 * i / 180 * Math.PI);
  		ctx.lineTo(off + x, off + (axisY.len / 2) + y);
  		var coord = new Coord(x, y);
  		sinusTrue.push(coord);
	}  

	ctx.lineWidth = 5;
	ctx.stroke();
	ctx.closePath();
}


function drawAxis(){
	ctx.beginPath();
	ctx.moveTo(off, off + (axisY.len / 2));
    ctx.lineTo(axisX.len + (off * 2), off + (axisY.len / 2));
    ctx.stroke();
    ctx.moveTo(off, off);
    ctx.lineTo(off, axisY.len + (off * 4));
    ctx.stroke();
    ctx.closePath();
}


function drawMarks(){

	let step = 0;
	//по x 
	for(let i = 0; i <= n; i += axisX.step){
    	ctx.save();
    	ctx.translate(off + sinusTrue[i].x, off - 10 + (axisY.len / 2));
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(sinusTrue[i].x, 0, 0);
    	ctx.restore();
    }

    //перестроить
    //по y
    for(let i = 0; i <= n; i += axisY.step){
    	ctx.save();
    	ctx.translate(off - (off - 10), off + (axisY.len / 2) + sinusTrue[i].y);
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(sinusTrue[i].y.toString().substring(0, 6), 0, 0);
    	ctx.restore();
    }
}


function drawSpline(){
	let S = 0,
		i_ = 0,
		i1 = 0,
	    m = new Array(),
	    uPolin = new Array();
    	h = 200,
    	step = 10;

    for(let i = 0; i <= n / step; i++) m[i] = 0;
    m[0] = (4 * sinusTrue[step].y - sinusTrue[step * 2].y - 3 * sinusTrue[0].y) / 2 * h;
	m[10] = (3 * sinusTrue[n].y - sinusTrue[n - (step * 2)].y - 3 * sinusTrue[n - step].y) / 2 * h;

    for(let i = 1; i < 10; i++) m[i] = (sinusTrue[i * step + step].y - sinusTrue[i * step - step].y) / 2 * h;

    for(let i = 0; i <= n; i++){
    	i1 = Math.floor(i / 10) * 10;
    	i_ = i / 100;
    	if (i % 10 != 0)
    	S = (((Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (2 * (i_ -sinusTrue[i1].x) + h)) / Math.pow(h, 3)) * sinusTrue[Math.floor(i/10)*10].y) + 
    		(((Math.pow(i_ - sinusTrue[i1].x, 2) * (2 * (sinusTrue[i1 + 10].x - i_) + h)) / Math.pow(h, 3)) * sinusTrue[Math.floor(i/10)*10 + 10].y) + 
    		(((Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (i_ - sinusTrue[i1].x) ) / Math.pow(h, 2)) * m[Math.floor(i/10)]  ) + 
    		(((Math.pow(i_ - sinusTrue[i1].x, 2) * (i_ - sinusTrue[i1 + 10].x) ) / Math.pow(h, 2)) * m[Math.floor(i/10) + 1]);
    	else S = sinusTrue[i].y;

    	console.log(S);
    	uPolin.push(S);
    	ctx.fillStyle = "red";
    	ctx.fillRect(sinusTrue[i].x + off - 2.5, off + (axisY.len / 2) + S - 2.5, 5, 5);
	}
	
	for(let i = 0; i < n; i++){
		ctx.beginPath();
		ctx.moveTo(sinusTrue[i].x + off, off + (axisY.len / 2) + uPolin[i]);
		ctx.lineTo(sinusTrue[i + 1].x  + off, off + (axisY.len / 2) + uPolin[i]);
		ctx.lineWidth = 1.75;
		ctx.strokeStyle = "red";
		ctx.stroke();
		ctx.closePath();
	}
}




//точка входа
window.onload = function(){
	
	drawAxis();
	drawCinus();
	drawMarks();

	//создание массива значений с шагом 
	for(let i = 0; i <= n; i++){
		if(i % 10 == 0){
			sinusSpline.push(sinusTrue[i]);
		}
	}
	drawSpline();

}



</script>