<canvas id="canvas" width="1200" height="500"></canvas>
<style>
	canvas{
		transform: rotate(180deg) rotateY(180deg);
	}
</style>





<script type="text/javascript">	


var canvas = document.getElementById('canvas');
var ctx = canvas.getContext("2d");

function Coord(x, y){
	this.x = x;
	this.y = y;
};

function Axle(len, step){
	this.len = len;
	this.step = step;
}


let h           = 0.01,
	cS          = 11, //масштаб
	off         = 50, //смещение в пикселях
	n           = 100,
	sinusTrue   = new Array(),
	stepSpline  = 20,
	sinusSpline = new Array();

//оси
let axisX = new Axle(1000, 20),
	axisY = new Axle(200, 100);
	

function inRad(num) {
	return num * Math.PI / 180;
}


function drawCinus(){
	ctx.strokeStyle = "green";
	ctx.beginPath();

	for (i = 0; i <= n; i++) {
  		x = i * 3;
  		y = 120 * Math.sin(12 * i / 180 * Math.PI);
  		ctx.lineTo(off + x, off + (axisY.len / 2) + y);
  		var coord = new Coord(x, y);
  		sinusTrue.push(coord);
  		console.log(coord);
	}  

	ctx.lineWidth = 1.5;
	ctx.stroke();
	ctx.closePath();
}


function drawAxis(){
	ctx.beginPath();
	ctx.moveTo(off, off + (axisY.len / 2));
    ctx.lineTo(axisX.len + (off * 2), off + (axisY.len / 2));
    ctx.stroke();
    ctx.moveTo(off, off);
    ctx.lineTo(off, axisY.len + (off * 4));
    ctx.stroke();
    ctx.closePath();
}


function drawMarks(){

	let step = 0;
	//по x 
	for(let i = 0; i <= n; i += axisX.step){
    	ctx.save();
    	ctx.translate(off + sinusTrue[i].x, off - 10 + (axisY.len / 2));
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(sinusTrue[i].x, 0, 0);
    	ctx.restore();
    }

    //перестроить
    //по y
    for(let i = 0; i <= n; i += axisY.step){
    	ctx.save();
    	ctx.translate(off - (off - 10), off + (axisY.len / 2) + sinusTrue[i].y);
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(sinusTrue[i].y.toString().substring(0, 6), 0, 0);
    	ctx.restore();
    }
}


function drawSpline(){
	let S = 0,
		i_ = 0,
		i1 = 0,
	    m = new Array(),
	    uPolin = new Array();
    	h = 0.1;

    for(let i = 0; i <= 10; i++) m[i] = 0;
    m[0] = (4 * sinusTrue[10].y - sinusTrue[20].y - 3 * sinusTrue[0].y) / 2 * h;
	m[10] = (3 * sinusTrue[100].y - sinusTrue[80].y - 3 * sinusTrue[90].y) / 2 * h;

    for(let i = 1; i < 10; i++) m[i] = (sinusTrue[i * 10 + 10].y - sinusTrue[i * 10 - 10].y) / 2 * h;

    for(let i = 0; i <= n; i++) {
    	i1 = Math.floor(i / 10) * 10;
    	i_ = i / 100;
    	if (i % 10 != 0)
    	S = (((Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (2 * (i_ -sinusTrue[i1].x) + h)) / Math.pow(h, 3)) * sinusTrue[Math.floor(i/10)*10].y) + 
    		(((Math.pow(i_ - sinusTrue[i1].x, 2) * (2 * (sinusTrue[i1 + 10].x - i_) + h)) / Math.pow(h, 3)) * sinusTrue[Math.floor(i/10)*10 + 10].y) + 
    		(((Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (i_ - sinusTrue[i1].x) ) / Math.pow(h, 2)) * m[Math.floor(i/10)]  ) + 
    		(((Math.pow(i_ - sinusTrue[i1].x, 2) * (i_ - sinusTrue[i1 + 10].x) ) / Math.pow(h, 2)) * m[Math.floor(i/10) + 1]);
    	else S = sinusTrue[i].y;
    	uPolin.push(S);

    	ctx.fillRect(sinusTrue[i].x + off, off + (axisY.len / 2) + S, 5, 5);
	}
	
	// for(let i = 0; i <= 100; i++){
	// 	ctx.beginPath();
	// 	ctx.moveTo(sinusTrue[i].x + off, uPolin[i] * n * cS + off + 2.5);
	// 	ctx.lineTo((i + 1) * cS + off, uPolin[i + 1] * n * cS + off + 2.5);
	// 	ctx.lineWidth = 1.5;
	// 	ctx.strokeStyle = "blue";
	// 	ctx.stroke();
	// 	ctx.closePath();
	// }
}




//точка входа
window.onload = function(){
	
	drawAxis();
	drawCinus();
	drawMarks();

	//создание массива значений с шагом 
	for(let i = 0; i <= n; i += stepSpline){
		sinusSpline.push(sinusTrue[i]);
	}

	drawSpline();

}



</script>