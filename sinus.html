<div class="wrap">
	<canvas id="canvas" width="800" height="320"></canvas>
	<div>
		<div class="button" id="true">Точное решение</div>
		<div class="button" id="spline">Сплайн</div>
		<div class="button" id="lagrange">Лагранж</div>
	</div>
</div>


<style>
	canvas{
		transform: rotate(180deg) rotateY(180deg);
		margin-right: 20px;
		padding: 50px;
		box-shadow: inset -3px -1px 20px -6px rgba(0,0,0,0.75);
	}

	.wrap{
		display: flex;
		margin: 30px;
	}

	.button{
		padding: 7px 10px;
		border: 1.5px solid #000;
		margin-top: 20px;
		font-size: 18px;
		max-width: 100px;
		text-align: center;
	}

	.button:first-child{
		margin-top: 0px;
	}

	.button:hover{
		transition: 0.3s;
		background: #000;
		color: #fff;
		cursor: pointer;
	}

	.active{
		transition: 0.3s;
		background: #000;
		color: #fff;
	}

</style>


<script>
	
	function inRad(num) {
		return num * Math.PI / 180;
	}
</script>


<script type="text/javascript">	

//сделать подсчет функций !!ОТДЕЛЬНО!! чтобы можно было сделать клик отключения того или иного пострения и рисовать все в отдельных функциях
//посмотреть шаг сплайна


var canvas = document.getElementById('canvas');
var ctx = canvas.getContext("2d");

function Coord(x, y){
	this.x = x;
	this.y = y;
};

function Axle(len, step){
	this.len = len;
	this.step = step;
	this.marks = new Array();
}

let h             = 0.01,
	cS            = 140, //масштаб
	off           = 50, //смещение в пикселях
	n             = 280,
	sinusTrue     = new Array(),
	sinusSpline   = new Array(),
	sinusLagrange = new Array(),
	//оси	
	axisX = new Axle(540, 120),
	axisY = new Axle(200, 25);


function calcTrueSinus(){
	//первое значение
	x = 0;
	y = Math.sin(10 * x);
	var coord = new Coord(x, y);
	sinusTrue.push(coord);

	//остальные значения
	for(i = 1; i <= n; i++) {
  		x = sinusTrue[i - 1].x + h;
		y = Math.sin(10 * x); 
  		var coord = new Coord(x, y);
  		sinusTrue.push(coord);
	}
}


function calcAxisMarks(){

	//по y
	let countY     = axisY.len / axisY.step,
		stepSinusY = 0,
		minMark    = 9999999,
		maxMark    = -9999999;

	for(let i = 0; i < n; i++){
		if(minMark > sinusTrue[i].y){
			minMark = sinusTrue[i].y;
		}
		if(maxMark < sinusTrue[i].y){
			maxMark = sinusTrue[i].y;
		}
	}

	stepSinusY = maxMark * 2 / countY;
	axisY.marks.push(Number(minMark.toString().substring(0, 4)));

	for(let i = 1; i < countY; i++){
		var mark = axisY.marks[i - 1] + stepSinusY;
		mark = mark.toString().substring(0, 4);
		mark = Number(mark);
		axisY.marks.push(mark);
	}

	//по x
	let countX     = axisX.len / axisX.step,
		stepSinusX = sinusTrue[n].x / countX,
		firstMark  = sinusTrue[0].x;

	axisX.marks.push(Number(firstMark.toString().substring(0, 4)));
	for(let i = 1; i < countX; i++){
		var mark = axisX.marks[i - 1] + stepSinusX;
		mark = mark.toString().substring(0, 4);
		mark = Number(mark);
		axisX.marks.push(mark);
	}
	
}


function calcSplineSinus(){
	let S  = 0,
		i_ = 0,
		i1 = 0,
		mN = n / 10,
	    m  = new Array();
   		hSpline = 0.1;

   	//наклоны
	for(let i = 0; i <= mN; i++) m[i] = 0;
    m[0] = (4 * sinusTrue[10].y - sinusTrue[20].y - 3 * sinusTrue[0].y ) / 2 * hSpline;
	m[mN] = (3 * sinusTrue[n].y - sinusTrue[n - 20].y - 3 * sinusTrue[n - 10].y ) / 2 * hSpline;
    for(let i = 1; i < mN; i++) m[i] = (sinusTrue[i * 10 + 10].y - sinusTrue[i * 10 - 10].y) / 2 * hSpline;

    //значения функции
   	for(let i = 0; i <= n; i++) {
    	i1 = Math.floor(i / 10) * 10;
    	i_ = i / 100;
    	if (i % 10 != 0)
    	S = (((( Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (2 * (i_ - sinusTrue[i1].x) + hSpline) ) / Math.pow(hSpline, 3)) * sinusTrue[Math.floor(i / 10) * 10].y) + 
    		((( Math.pow(i_ - sinusTrue[i1].x, 2) * (2 * (sinusTrue[i1 + 10].x - i_) + hSpline) ) / Math.pow(hSpline, 3)) * sinusTrue[Math.floor(i / 10) *  10 + 10].y) + 
    		((( Math.pow(sinusTrue[i1 + 10].x - i_, 2) * (i_ - sinusTrue[i1].x) ) / Math.pow(hSpline, 2)) * m[Math.floor(i / 10)]) + 
    		((( Math.pow(i_ - sinusTrue[i1].x, 2) * (i_ - sinusTrue[i1 + 10].x) ) / Math.pow(hSpline, 2)) * m[Math.floor(i / 10) + 1]  ) );
    	else{
    		S = sinusTrue[i].y;
    	} 
    	var coord = new Coord(sinusTrue[i].x, S);
    	sinusSpline.push(coord);
	}
}


function calcSplineLagrange(){

	let degree = 10;

	function calcP(x, i, deg){
		let num = 1,
			dem = 1;

		for(let j = 0; j < deg; j++){
			if(j != i){
				num *= x - sinusTrue[j * 10].x;
				dem *= sinusTrue[i * 10].x - sinusTrue[j * 10].x;
			}
		}
		return num / dem;
	}

	function calcL(x, deg){
		let l = 0;
		for(let i = 0; i < deg; i++){
			console.log(sinusTrue[i * 10], i * 10);
			l += calcP(x, i, deg) * sinusTrue[i * 10].y;
		}
		return l;
	}

	for(let x = 0; x <= n; x++){
		let y = calcL(x / 100, degree);
		var coord = new Coord(x / 100, y);
		sinusLagrange.push(coord);
	}
}


function drawCinus(){
	ctx.strokeStyle = "blue";
	ctx.beginPath();
	for(i = 0; i <= n; i++){
		ctx.lineTo(off + sinusTrue[i].x * cS, off + (axisY.len / 2) + (sinusTrue[i].y * cS));
	}
	ctx.lineWidth = 3.5;
	ctx.stroke();
	ctx.closePath();
}


function drawAxisMarks(){
	//x
	for(let i = 0; i < axisX.marks.length; i++){
		ctx.save();
    	ctx.translate(axisX.marks[i] * cS + off + 5, off - 10 + (axisY.len / 2));
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(axisX.marks[i], 0, 0);
    	ctx.restore();
	}

	//y
	for(let i = 0; i < axisY.marks.length; i++){
		if(!axisY.marks[i]){
			continue;
		}
		ctx.save();
    	ctx.translate(off - 30, off + cS * axisY.marks[i] + (axisY.len / 2));
    	ctx.rotate(inRad(180));
    	ctx.scale(-1, 1)
    	ctx.fillText(axisY.marks[i], 0, 0);
    	ctx.restore();
	}
	
}


function drawAxis(){
	ctx.strokeStyle = "black";
	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.moveTo(off, off + (axisY.len / 2));
    ctx.lineTo(axisX.len + (off * 2), off + (axisY.len / 2));
    ctx.stroke();
    ctx.moveTo(off, off - (axisY.len / 2));
    ctx.lineTo(off, axisY.len + (off * 2));
    ctx.stroke();
    ctx.closePath();
}


function drawSpline(){
	for(let i = 0; i < n; i++){
		ctx.strokeStyle = "red";
		ctx.beginPath();
		ctx.moveTo(off + sinusSpline[i].x * cS, off + (axisY.len / 2) + (sinusSpline[i].y * cS));
		ctx.lineTo(off + sinusSpline[i + 1].x * cS, off + (axisY.len / 2) + (sinusSpline[i + 1].y * cS));
		ctx.lineWidth = 2.4;
		ctx.stroke();
		ctx.closePath();
	}
}


function drawSplineLagrange(){
	for(let i = 0; i < sinusLagrange.length - 1; i++){
		ctx.strokeStyle = "green";
		ctx.beginPath();
		ctx.moveTo(off + sinusLagrange[i].x * cS, off + (axisY.len / 2) + (sinusLagrange[i].y * cS));
		ctx.lineTo(off + sinusLagrange[i + 1].x * cS, off + (axisY.len / 2) + (sinusLagrange[i + 1].y * cS));
		ctx.lineWidth = 2.4;
		ctx.stroke();
		ctx.closePath();
	}
}


let flags = {
	sinusTrue    : true,
	sinusSpline  : true,
	sinusLagrange: true,
}

function minusTrue(){
	ctx.clearRect(0, 0, 800, 320);

	if(!flags.sinusTrue){
		drawCinus();
		flags.sinusTrue = true;
		this.classList.remove("active");
	}else{
		flags.sinusTrue = false;
		this.classList.add("active");
	}

	if(flags.sinusSpline){
		drawSpline();
	}

	if(flags.sinusLagrange){
		drawSplineLagrange();
	}
	
	drawAxis();
	drawAxisMarks();

}


function minusSpline(){
	ctx.clearRect(0, 0, 800, 320);

	if(flags.sinusTrue){
		drawCinus();
	}

	if(!flags.sinusSpline){
		drawSpline();
		flags.sinusSpline = true;
		this.classList.remove("active");
	}else{
		flags.sinusSpline = false;
		this.classList.add("active");
	}

	if(flags.sinusLagrange){
		drawSplineLagrange();
	}
	
	drawAxis();
	drawAxisMarks();
}


function minusLagrange(){
	ctx.clearRect(0, 0, 800, 320);

	if(flags.sinusTrue){
		drawCinus();
	}

	if(flags.sinusSpline){
		drawSpline();
	}

	if(!flags.sinusLagrange){
		drawSplineLagrange();
		flags.sinusLagrange = true;
		this.classList.remove("active");
	}else{
		flags.sinusLagrange = false;
		this.classList.add("active");
	}
	
	drawAxis();
	drawAxisMarks();
}


//точка входа
window.onload = function(){

	//считаем значения
	calcTrueSinus();
	calcAxisMarks();
	calcSplineSinus();
	calcSplineLagrange();

	console.log(sinusTrue, sinusLagrange);

	//рисуем графики
	drawCinus();
	drawSpline();
	drawSplineLagrange();
	drawAxis();
	drawAxisMarks();

	document.getElementById('true').addEventListener('click', minusTrue, false);
	document.getElementById('spline').addEventListener('click', minusSpline, false);
	document.getElementById('lagrange').addEventListener('click', minusLagrange, false);
	
}

</script>
